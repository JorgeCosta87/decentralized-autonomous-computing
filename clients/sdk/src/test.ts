import { createSolanaClient } from 'gill';
import { DacFrontendClient, NodeType, DAC_PROGRAM_ID, IpfsClient, WaitMode } from './index.js';
import { NodeStatus } from './generated/dac/types/index.js';
import { deriveNetworkConfigAddress, deriveNodeInfoAddress, deriveAgentAddress, deriveGoalAddress, deriveTaskAddress } from './dacPdas.js';
import { loadTestKeypairs } from './load-test-keypairs.js';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { AgentStatus, GoalStatus, TaskStatus } from './generated/dac/index.js';

/**
 * Test file for DAC SDK functions
 * 
 * Usage:
 *   npm run test:run
 *   or
 *   npx tsx src/test.ts
 * 
 * Note: 
 *   - Run 'cd agent-network && ./scripts/generate_keypair.sh' to generate all keypairs
 *   - All keypairs are saved to project root (generated by generate_keypair.sh)
 *   - Requires IPFS node running on localhost:5001
 */

// Configuration
const SOLANA_RPC = "localnet";
const IPFS_URL = "http://localhost:5001";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

async function main() {
  console.log('ğŸš€ Starting DAC SDK Tests\n');
  console.log(`RPC URL: ${SOLANA_RPC}`);
  console.log(`IPFS URL: ${IPFS_URL}`);
  console.log(`Program ID: ${DAC_PROGRAM_ID}\n`);

  // Initialize clients
  const solanaClient = createSolanaClient({ urlOrMoniker: SOLANA_RPC });
  const dacClient = new DacFrontendClient(solanaClient);
  const ipfsClient = new IpfsClient({ apiUrl: IPFS_URL });

  // Load test keypairs (generated by agent-network/scripts/generate_keypair.sh)
  console.log('ğŸ“ Loading Test Keypairs...\n');
  const keypairs = await loadTestKeypairs();

  console.log('Loaded Keypairs:');
  console.log(`  Authority:         ${keypairs.authority.address}`);
  console.log(`  Node Owner:        ${keypairs.nodeOwner.address}`);
  console.log(`  Public Nodes:      ${keypairs.publicNodes.length}`);
  keypairs.publicNodes.forEach((node, i) => {
    console.log(`    Public Node #${i + 1}: ${node.address}`);
  });
  console.log(`  Confidential Nodes: ${keypairs.confidentialNodes.length}`);
  keypairs.confidentialNodes.forEach((node, i) => {
    console.log(`    Confidential Node #${i + 1}: ${node.address}`);
  });
  console.log('');

  // ============================================================================
  // Test 1: Initialize Network
  // ============================================================================
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Test 1: Initialize Network');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

  const existingNetworkConfig = await dacClient.getNetworkConfig(keypairs.authority.address);
  
  if (existingNetworkConfig) {
    console.log('âœ… Network already initialized!');
    console.log('  Network Config Details:');
    console.log(`    Network Config CID: ${existingNetworkConfig.cidConfig}`);
    console.log(`    Agent Count: ${existingNetworkConfig.agentCount}`);
    console.log(`    Goal Count: ${existingNetworkConfig.goalCount}`);
    console.log(`    Task Count: ${existingNetworkConfig.taskCount}`);
    console.log(`    Confidential Node Count: ${existingNetworkConfig.confidentialNodeCount}`);
    console.log(`    Public Node Count: ${existingNetworkConfig.publicNodeCount}\n`);
    console.log('Skipping initialization...\n');
  } else {
    try {
      // Upload network config to IPFS
      console.log('Uploading network config to IPFS...');
      const networkConfigYaml = readFileSync(join(__dirname, '../test-configs/network-config.yaml'), 'utf-8');
      const networkConfigCid = await ipfsClient.uploadYamlConfig(networkConfigYaml, 'network-config.json');
      console.log(`  Network Config CID: ${networkConfigCid}\n`);

      const allocateGoals = 5n;
      const allocateTasks = 5n;
      const approvedCodeMeasurements = [
        {
          measurement: new Uint8Array([
            229, 58, 231, 48, 0, 103, 31, 222, 162, 242, 225, 237, 113, 102, 105, 80,
            150, 168, 167, 186, 161, 187, 226, 22, 159, 58, 36, 194, 139, 99, 115, 84
          ]),
          version: { major: 1, minor: 0, patch: 0 },
        },
      ];

      console.log('Network not found. Initializing network...\n');
      console.log('Parameters:');
      console.log(`  Allocate Goals: ${allocateGoals}`);
      console.log(`  Allocate Tasks: ${allocateTasks}`);
      console.log(`  Approved Code Measurements: ${approvedCodeMeasurements.length}\n`);

      const { signature: initSignature, networkConfigAddress } =
        await dacClient.initializeNetwork({
          authority: keypairs.authority,
          cidConfig: networkConfigCid,
          allocateGoals,
          allocateTasks,
          approvedCodeMeasurements,
          requiredValidations: 1,
        });

      console.log('âœ… Network initialized successfully!');
      console.log(`  Transaction Signature: ${initSignature}`);
      console.log(`  Network Config Address: ${networkConfigAddress}\n`);

      // Verify network config was created
      const networkConfig = await dacClient.getNetworkConfig(keypairs.authority.address);
      if (networkConfig) {
        console.log('âœ… Network config fetched:');
        console.log(`  Agent Count: ${networkConfig.agentCount}`);
        console.log(`  Goal Count: ${networkConfig.goalCount}`);
        console.log(`  Task Count: ${networkConfig.taskCount}`);
        console.log(`  Confidential Node Count: ${networkConfig.confidentialNodeCount}`);
        console.log(`  Public Node Count: ${networkConfig.publicNodeCount}\n`);
      } else {
        console.log('âš ï¸  Network config not found (may need to wait for confirmation)\n');
      }
    } catch (error) {
      console.error('âŒ Failed to initialize network:');
      console.error(error);
      process.exit(1);
    }
  }

  // ============================================================================
  // Test 2: Register All Nodes
  // ============================================================================
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Test 2: Register All Nodes');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

  try {
    const networkConfigData = await dacClient.getNetworkConfig(keypairs.authority.address);
    if (!networkConfigData) {
      throw new Error('Network config not found. Run initializeNetwork first.');
    }

    const networkConfigAddr = await deriveNetworkConfigAddress(DAC_PROGRAM_ID, keypairs.authority.address);

    async function registerNodeIfNeeded(
      nodeKeypair: Awaited<ReturnType<typeof loadTestKeypairs>>['publicNodes'][0],
      nodeType: NodeType,
      nodeIndex?: number
    ): Promise<void> {
      const nodeLabel = nodeIndex !== undefined 
        ? `${nodeType === NodeType.Public ? 'Public' : 'Confidential'} Node #${nodeIndex + 1}`
        : `${nodeType === NodeType.Public ? 'Public' : 'Confidential'} Node`;
      
      console.log(`Checking ${nodeLabel} registration...`);
      console.log(`  Node Pubkey: ${nodeKeypair.address}`);
      
      const existingNodeInfo = await dacClient.getNodeInfo(nodeKeypair.address);
      
      if (existingNodeInfo) {
        const nodeInfoAddress = await deriveNodeInfoAddress(DAC_PROGRAM_ID, nodeKeypair.address);
        console.log(`âœ… ${nodeLabel} already registered!`);
        console.log(`  Node Info Address: ${nodeInfoAddress}`);
        console.log(`  Node Type: ${existingNodeInfo.nodeType}`);
        console.log(`  Status: ${existingNodeInfo.status}\n`);
      } else {
        console.log(`Registering ${nodeLabel}...`);
        const { signature, nodeInfoAddress, nodeTreasuryAddress } =
          await dacClient.registerNode({
            owner: keypairs.nodeOwner,
            networkConfig: networkConfigAddr,
            nodePubkey: nodeKeypair.address,
            nodeType,
          });

        console.log(`âœ… ${nodeLabel} registered successfully!`);
        console.log(`  Transaction Signature: ${signature}`);
        console.log(`  Node Info Address: ${nodeInfoAddress}`);
        console.log(`  Node Treasury Address: ${nodeTreasuryAddress}\n`);
      }
    }

    // Register all public nodes
    console.log(`Registering ${keypairs.publicNodes.length} Public Node(s)...\n`);
    for (let i = 0; i < keypairs.publicNodes.length; i++) {
      await registerNodeIfNeeded(keypairs.publicNodes[i], NodeType.Public, i);
    }

    // Register all confidential nodes
    console.log(`Registering ${keypairs.confidentialNodes.length} Confidential Node(s)...\n`);
    for (let i = 0; i < keypairs.confidentialNodes.length; i++) {
      await registerNodeIfNeeded(keypairs.confidentialNodes[i], NodeType.Confidential, i);
    }

    console.log('âœ… All nodes registered!\n');
  } catch (error) {
    console.error('âŒ Failed to register nodes:');
    console.error(error);
    process.exit(1);
  }

  // ============================================================================
  // Test 2.5: Wait for Nodes to be Claimed and Activate
  // ============================================================================
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Test 2.5: Wait for Nodes to be Claimed and Activate');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

  try {
    const publicNodePubkeys = keypairs.publicNodes.map((node) => node.address);

    console.log(`Waiting for ${publicNodePubkeys.length} Public Node(s) to be claimed...`);

    try {
      // Wait for nodes to reach AwaitingValidation status (after claim)
      // Wait for all nodes to be claimed
      const claimedNodes = await dacClient.waitForNodesStatus(publicNodePubkeys, NodeStatus.AwaitingValidation, {
        timeoutMs: 10000, // 60 seconds
        waitMode: WaitMode.First,
      });

      console.log(`âœ… ${claimedNodes.length} public node(s) have been claimed and are in AwaitingValidation state!\n`);

      // Now activate all nodes
      console.log('Activating all public nodes...\n');
      for (let i = 0; i < claimedNodes.length; i++) {
        const nodeKeypair = keypairs.publicNodes[i];
        const nodeLabel = `Public Node #${i + 1}`;

        console.log(`Activating ${nodeLabel}...`);
        console.log(`  Node Pubkey: ${nodeKeypair.address}`);

        const signature = await dacClient.activateNode({
          authority: keypairs.authority,
          nodePubkey: nodeKeypair.address,
        });

        console.log(`âœ… ${nodeLabel} activated successfully!`);
        console.log(`  Transaction Signature: ${signature}\n`);

        // Verify activation
        const updatedNodeInfo = await dacClient.getNodeInfo(nodeKeypair.address);
        if (updatedNodeInfo) {
          console.log(`âœ… Verified ${nodeLabel} activation:`);
          console.log(`  Status: ${updatedNodeInfo.status}`);
          console.log(`  Node Type: ${updatedNodeInfo.nodeType}\n`);
        }
      }

      console.log('âœ… All nodes activated successfully!\n');
    } catch (error: any) {
      if (error.message?.includes('Timeout')) {
        console.log('âš ï¸  Timeout waiting for nodes to be claimed.');
        console.log('   Please ensure public nodes are running and claiming nodes.');
        console.log('   Run: cd agent-network/public-node && cargo run\n');
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('âŒ Failed to activate nodes:');
    console.error(error);
    process.exit(1);
  }

  // ============================================================================
  // Test 4: Create Agent
  // ============================================================================
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Test 4: Create Agent');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

  let agentSlotId: bigint;
  let agentAddress: any;

  try {
    const networkConfigAddr = await deriveNetworkConfigAddress(DAC_PROGRAM_ID, keypairs.authority.address);
    const networkConfigData = await dacClient.getNetworkConfig(keypairs.authority.address);
    
    if (!networkConfigData) {
      throw new Error('Network config not found. Run initializeNetwork first.');
    }

    // Check if agent already exists
    agentSlotId = networkConfigData.agentCount;
    agentAddress = await deriveAgentAddress(DAC_PROGRAM_ID, networkConfigAddr, agentSlotId);
    const existingAgent = await dacClient.getAgent(agentAddress);

    if (existingAgent) {
      console.log('âœ… Agent already exists!');
      console.log(`  Agent Address: ${agentAddress}`);
      console.log(`  Agent Slot ID: ${agentSlotId}`);
      console.log(`  Agent Config CID: ${existingAgent.agentConfigCid}`);
      console.log(`  Status: ${existingAgent.status}\n`);
    } else {
      // Upload agent config to IPFS
      console.log('Uploading agent config to IPFS...');
      const agentConfigYaml = readFileSync(join(__dirname, '../test-configs/agent-config.yaml'), 'utf-8');
      const agentConfigFilename = `${agentSlotId}-agent-config.json`;
      const agentConfigCid = await ipfsClient.uploadYamlConfig(agentConfigYaml, agentConfigFilename);
      console.log(`  Agent Config CID: ${agentConfigCid}\n`);

      console.log('Creating agent...');
      const { signature, agentAddress: newAgentAddress, agentSlotId: newAgentSlotId } = await dacClient.createAgent({
        agentOwner: keypairs.authority,
        networkConfig: networkConfigAddr,
        agentConfigCid,
      });

      agentSlotId = newAgentSlotId;
      agentAddress = newAgentAddress;

      console.log('âœ… Agent created successfully!');
      console.log(`  Transaction Signature: ${signature}`);
      console.log(`  Agent Address: ${agentAddress}`);
      console.log(`  Agent Slot ID: ${agentSlotId}\n`);

      // Verify agent was created
      const createdAgent = await dacClient.getAgent(agentAddress);
      if (createdAgent) {
        console.log('âœ… Agent verified:');
        console.log(`  Agent Config CID: ${createdAgent.agentConfigCid}`);
        console.log(`  Status: ${createdAgent.status}`);
        
        if (createdAgent.status === AgentStatus.Pending) {
          console.log('\nâš ï¸  Agent is in Pending state - needs validation');
          console.log('   Run confidential node to validate: cd agent-network/confidential-node && cargo run');
        }
        console.log('');
      }
    }
  } catch (error) {
    console.error('âŒ Failed to create agent:');
    console.error(error);
    process.exit(1);
  }

  // ============================================================================
  // Test 5: Create and Set Goal
  // ============================================================================
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Test 5: Create and Set Goal');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

  try {
    const networkConfigAddr = await deriveNetworkConfigAddress(DAC_PROGRAM_ID, keypairs.authority.address);
    const networkConfigData = await dacClient.getNetworkConfig(keypairs.authority.address);
    
    if (!networkConfigData) {
      throw new Error('Network config not found.');
    }

    // Loop through all agents to find an Active one
    console.log('Searching for Active agent...');
    console.log(`  Total agents in network: ${networkConfigData.agentCount}\n`);
    
    let activeAgent = null;
    let activeAgentSlotId = null;
    let activeAgentAddress = null;
    
    for (let i = 0n; i < networkConfigData.agentCount; i++) {
      const currentAgentAddress = await deriveAgentAddress(DAC_PROGRAM_ID, networkConfigAddr, i);
      const agent = await dacClient.getAgent(currentAgentAddress);
      
      if (agent) {
        console.log(`  Agent ${i}: ${agent.status}`);
        
        if (agent.status === AgentStatus.Active) {
          activeAgent = agent;
          activeAgentSlotId = i;
          activeAgentAddress = currentAgentAddress;
          break;
        }
      }
    }
    
    if (!activeAgent) {
      console.log('\nâš ï¸  No Active agents found!');
      console.log('   All agents must be validated by a confidential node first.');
      console.log('\nâ„¹ï¸  To validate agents:');
      console.log('   1. Start confidential node: cd agent-network/confidential-node && cargo run');
      console.log('   2. Validator will automatically validate pending agents');
      console.log('   3. Re-run this test after validation\n');
      process.exit(0);
    }

    console.log(`\nâœ… Found Active agent at slot ${activeAgentSlotId}!`);
    console.log(`  Agent Address: ${activeAgentAddress}`);
    console.log(`  Agent Config CID: ${activeAgent.agentConfigCid}\n`);
    
    // Use the active agent (we know these are not null because we checked above)
    agentSlotId = activeAgentSlotId!;
    agentAddress = activeAgentAddress!;

    // Create a new goal (which also creates a task automatically)
    console.log('Creating goal (which also creates a task)...');
    const { signature: createGoalSignature, goalAddress, goalSlotId, taskAddress, taskSlotId } = await dacClient.createGoal({
      payer: keypairs.authority,
      owner: keypairs.authority,
      networkConfig: networkConfigAddr,
      isOwned: true,
      isConfidential: false,
    });

    console.log('âœ… Goal and task created successfully!');
    console.log(`  Transaction Signature: ${createGoalSignature}`);
    console.log(`  Goal Address: ${goalAddress}`);
    console.log(`  Goal Slot ID: ${goalSlotId}`);
    console.log(`  Task Address: ${taskAddress}`);
    console.log(`  Task Slot ID: ${taskSlotId}\n`);

    // Verify goal and task were created
    const createdGoal = await dacClient.getGoal(networkConfigAddr, goalSlotId);
    const createdTask = await dacClient.getTask(networkConfigAddr, taskSlotId);
    
    if (createdGoal) {
      console.log('âœ… Goal verified:');
      console.log(`  Status: ${createdGoal.status}`);
      console.log(`  Linked Task: ${createdGoal.task}`);
    }
    
    if (createdTask) {
      console.log('âœ… Task verified:');
      console.log(`  Status: ${createdTask.status}\n`);
    }

    // Upload goal specification to IPFS
    console.log('Uploading goal specification to IPFS...');
    const goalSpecYaml = readFileSync(join(__dirname, '../test-configs/goal-specification.yaml'), 'utf-8');
    const specificationCid = await ipfsClient.uploadYamlConfig(goalSpecYaml, 'goal-specification.json');
    console.log(`  Goal Specification CID: ${specificationCid}\n`);

    console.log('Setting goal...');
    console.log('Parameters:');
    console.log(`  Goal Slot ID: ${goalSlotId}`);
    console.log(`  Agent Slot ID: ${agentSlotId}`);
    console.log(`  Task Slot ID: ${taskSlotId}`);
    console.log(`  Max Iterations: 5`);
    console.log(`  Initial Deposit: 0.5 SOL\n`);

    const setGoalSignature = await dacClient.setGoal({
      owner: keypairs.authority,
      networkConfig: networkConfigAddr,
      goalSlotId,
      agentSlotId,
      taskSlotId,
      specificationCid,
      maxIterations: 5n,
      initialDeposit: 500_000_000n,
    });

    console.log('âœ… Goal set successfully!');
    console.log(`  Transaction Signature: ${setGoalSignature}\n`);

  } catch (error) {
    console.error('âŒ Failed to set goal:');
    console.error(error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
